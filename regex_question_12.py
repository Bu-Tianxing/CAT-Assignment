#正则表达式无法验证信用卡号码是否真的有效，最终的结论要由信用卡的发行机构做出。
# 但是，正则表达式可用于在对信用卡号码做进一步处理之前，把有输入错误 的信用卡号码
# （比如多输入一位数字或少输入一位数字等情况）排除在外。
# 所有的信用卡都遵守同一种基本的编号方案：以特定的数字序列开头，号码的总位数是一个固定的值。
# MasterCard：总长度为16位数字，第一位数字永远是5，第二位数字是1~5。
# Visa卡的第一位号码永远是4，总长度是13位或16位数字（不存在14位或15位，所以这里不能使用数字区间）。
# American Express卡的号码总长度是15位，前2位号码必须是 34或37。
# Discover卡的号码总长度是16位，前4位号码必须是6011。
# Diners Club的号码总长度是14位，必须以300~305、36或38开头。
# 如果前3位号码是300~305，后面必须再有11位数字；如果前2位号码是36或38，则后面必须再有12位数字。

import re

def main():
    Cards = [
        "MasterCard: 5212345678901234",
        "Visa 1: 4123456789012",
        "Vusa 2: 4123456789012345",
        "Amex: 371234567890123",
        "Discover: 6011123456789012",
        "Diners Club: 38812345678901"
        ]
    # re1 = 5[1-5]\d{14}
    # re2 = 4(\d{12}|\d{14})
    # re3 = 3[47]\d{13}
    # re4 = 6011\d{14}
    # re5 = (30[0-5]\d{11})|(3[68]\d{12})

    regex = re.compile(r"(5[1-5]\d{14})|(4(\d{12}|\d{15}))|(3[47]\d{13})|(6011\d{12})|((30[0-5]\d{11})|(3[68]\d{12}))")
    for elem in Cards:
        print(regex.search(elem))

if __name__ == "__main__":
    main()

# 反思：
# 难度不大，就是表达式容易写错，得注意并列关系和括号
# re2 有优化空间4\d{12}(\d{3})?,我的写法只匹配16位的前13位。
# re5 可以先把(30[0-5]|36\d|38\d)并列起来，然后再\d{11}